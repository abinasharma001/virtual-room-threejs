<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Room - Move Objects</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
        }
        #info h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸŽ® Controls</h3>
        <strong>Click & Drag</strong> objects to move them<br>
        <strong>Mouse Wheel</strong> to zoom<br>
        <strong>Right Click + Drag</strong> to rotate view
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, raycaster, mouse;
        let selectedObject = null;
        let objects = [];
        let plane, offset, isDragging = false;
        let isRotating = false;
        let previousMousePosition = { x: 0, y: 0 };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Raycaster and mouse
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            offset = new THREE.Vector3();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);

            // Room floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d3561,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213e,
                side: THREE.DoubleSide
            });

            // Back wall
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            backWall.position.set(0, 5, -10);
            scene.add(backWall);

            // Left wall
            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-10, 5, 0);
            scene.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(10, 5, 0);
            scene.add(rightWall);

            // Create movable objects
            createObjects();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function createObjects() {
            // Cube
            const cubeGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(-3, 0.75, 0);
            cube.castShadow = true;
            cube.userData = { draggable: true };
            scene.add(cube);
            objects.push(cube);

            // Sphere
            const sphereGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x4ecdc4 });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(0, 0.8, -2);
            sphere.castShadow = true;
            sphere.userData = { draggable: true };
            scene.add(sphere);
            objects.push(sphere);

            // Cylinder
            const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
            const cylinderMaterial = new THREE.MeshStandardMaterial({ color: 0xffe66d });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.set(3, 1, 1);
            cylinder.castShadow = true;
            cylinder.userData = { draggable: true };
            scene.add(cylinder);
            objects.push(cylinder);

            // Torus
            const torusGeometry = new THREE.TorusGeometry(0.7, 0.3, 16, 100);
            const torusMaterial = new THREE.MeshStandardMaterial({ color: 0xa8dadc });
            const torus = new THREE.Mesh(torusGeometry, torusMaterial);
            torus.position.set(-2, 1, -4);
            torus.castShadow = true;
            torus.userData = { draggable: true };
            scene.add(torus);
            objects.push(torus);

            // Cone
            const coneGeometry = new THREE.ConeGeometry(0.6, 1.5, 32);
            const coneMaterial = new THREE.MeshStandardMaterial({ color: 0xf4a261 });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.set(2, 0.75, -3);
            cone.castShadow = true;
            cone.userData = { draggable: true };
            scene.add(cone);
            objects.push(cone);
        }

        function onMouseDown(event) {
            event.preventDefault();

            if (event.button === 2) {
                isRotating = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
                return;
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj.userData.draggable) {
                    selectedObject = obj;
                    isDragging = true;

                    const intersectPoint = intersects[0].point;
                    plane.setFromNormalAndCoplanarPoint(
                        camera.getWorldDirection(plane.normal),
                        intersectPoint
                    );
                    
                    offset.copy(intersectPoint).sub(selectedObject.position);
                    
                    selectedObject.material.emissive.setHex(0x444444);
                }
            }
        }

        function onMouseMove(event) {
            event.preventDefault();

            if (isRotating && event.buttons === 2) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                camera.position.x += deltaX * 0.01;
                camera.position.y -= deltaY * 0.01;
                camera.position.y = Math.max(1, Math.min(15, camera.position.y));
                camera.lookAt(0, 0, 0);

                previousMousePosition = { x: event.clientX, y: event.clientY };
                return;
            }

            if (!isDragging || !selectedObject) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectPoint);
            
            if (intersectPoint) {
                selectedObject.position.copy(intersectPoint.sub(offset));
                selectedObject.position.y = Math.max(selectedObject.position.y, 0.5);
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                isRotating = false;
                return;
            }

            if (selectedObject) {
                selectedObject.material.emissive.setHex(0x000000);
                selectedObject = null;
            }
            isDragging = false;
        }

        function onWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.5;
            camera.position.z += event.deltaY * 0.01 * zoomSpeed;
            camera.position.z = Math.max(3, Math.min(20, camera.position.z));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            objects.forEach(obj => {
                if (obj !== selectedObject) {
                    obj.rotation.y += 0.005;
                }
            });

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>